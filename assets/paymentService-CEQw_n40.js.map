{"version":3,"file":"paymentService-CEQw_n40.js","sources":["../../src/services/paymentService.ts"],"sourcesContent":["import { toast } from \"@/hooks/use-toast\";\r\nimport { promoCodeService } from './promoCodeService';\r\nimport { PromoCode } from '../types/promoCode';\r\nimport { balanceService } from './balanceService';\r\n\r\n// Payment gateway types\r\nexport type PaymentMethod = 'credit_card' | 'apple_pay' | 'google_pay' | 'balance';\r\nexport type SubscriptionPlan = 'monthly' | 'annual';\r\n\r\nexport interface PaymentDetails {\r\n  method: PaymentMethod;\r\n  cardNumber?: string;\r\n  cardExpiry?: string;\r\n  cardCVC?: string;\r\n  billingName?: string;\r\n  billingAddress?: string;\r\n  billingZip?: string;\r\n}\r\n\r\nexport interface SubscriptionDetails {\r\n  plan: SubscriptionPlan;\r\n  startDate: Date;\r\n  endDate: Date;\r\n  autoRenew: boolean;\r\n  status: 'active' | 'canceled' | 'expired' | 'pending';\r\n  paymentId: string;\r\n  promoCodeId?: string;\r\n  originalPrice?: number;\r\n  finalPrice?: number;\r\n}\r\n\r\nexport interface PaymentResult {\r\n  success: boolean;\r\n  paymentId?: string;\r\n  error?: string;\r\n  subscriptionDetails?: SubscriptionDetails;\r\n  promoCodeApplied?: boolean;\r\n  promoCode?: PromoCode;\r\n}\r\n\r\nclass PaymentService {\r\n  // Prices in USD\r\n  private prices = {\r\n    monthly: 7.99,\r\n    annual: 59.99\r\n  };\r\n\r\n  // Process payment for subscription\r\n  async processPayment(\r\n    plan: SubscriptionPlan,\r\n    paymentDetails: PaymentDetails,\r\n    promoCode?: string,\r\n    userId?: string\r\n  ): Promise<PaymentResult> {\r\n    try {\r\n      // Get base price for the plan\r\n      const originalPrice = this.prices[plan];\r\n      let finalPrice = originalPrice;\r\n      let appliedPromoCode: PromoCode | undefined;\r\n      let promoCodeId: string | undefined;\r\n\r\n      // Apply promo code if provided and user ID is available\r\n      if (promoCode && userId) {\r\n        const validationResult = await promoCodeService.validatePromoCode(\r\n          promoCode,\r\n          plan === 'monthly' ? 'Monthly' : 'Annual',\r\n          userId\r\n        );\r\n\r\n        if (validationResult.isValid && validationResult.promoDetails) {\r\n          // Calculate discounted price\r\n          finalPrice = this.calculateDiscountedPrice(\r\n            originalPrice,\r\n            validationResult.promoDetails\r\n          );\r\n\r\n          appliedPromoCode = validationResult.promoDetails;\r\n          promoCodeId = validationResult.promoDetails.id;\r\n        }\r\n      }\r\n\r\n      // Validate payment details first\r\n      if (!this.validatePaymentDetails(paymentDetails)) {\r\n        return {\r\n          success: false,\r\n          error: 'Invalid payment details'\r\n        };\r\n      }\r\n\r\n      // Generate payment ID\r\n      const paymentId = `pay_${Math.random().toString(36).substring(2, 15)}`;\r\n      const now = new Date();\r\n\r\n      // Calculate subscription end date based on plan\r\n      const endDate = new Date(now);\r\n      if (plan === 'monthly') {\r\n        endDate.setMonth(endDate.getMonth() + 1);\r\n      } else {\r\n        endDate.setFullYear(endDate.getFullYear() + 1);\r\n      }\r\n\r\n      // If promo code gives free months, adjust end date\r\n      if (appliedPromoCode &&\r\n          appliedPromoCode.discountType === 'free' &&\r\n          appliedPromoCode.duration === 'days' &&\r\n          appliedPromoCode.durationValue) {\r\n        endDate.setDate(endDate.getDate() + appliedPromoCode.durationValue);\r\n      }\r\n\r\n      // Create subscription details\r\n      const subscriptionDetails: SubscriptionDetails = {\r\n        plan,\r\n        startDate: now,\r\n        endDate,\r\n        autoRenew: true,\r\n        status: 'pending', // Start as pending until payment is confirmed\r\n        paymentId,\r\n        promoCodeId,\r\n        originalPrice,\r\n        finalPrice\r\n      };\r\n\r\n      // Convert price to IDR (assuming prices are in USD)\r\n      const priceInIDR = Math.round(finalPrice * 15000); // Approximate USD to IDR conversion\r\n\r\n      // Use real balance deduction with consistent user ID\r\n      const userIdToUse = userId || this.getTempUserId();\r\n      const paymentDescription = `Subscription to ${plan === 'monthly' ? 'Monthly' : 'Annual'} Plan`;\r\n\r\n      // Process the actual payment by deducting from user balance\r\n      const deductResult = await balanceService.deductBalance(\r\n        userIdToUse,\r\n        priceInIDR,\r\n        paymentDescription,\r\n        paymentDetails.method\r\n      );\r\n\r\n      if (!deductResult.success) {\r\n        return {\r\n          success: false,\r\n          error: deductResult.error || 'Payment failed'\r\n        };\r\n      }\r\n\r\n      // Payment successful, update subscription status\r\n      subscriptionDetails.status = 'active';\r\n\r\n      // Return successful result\r\n      const result: PaymentResult = {\r\n        success: true,\r\n        paymentId,\r\n        subscriptionDetails,\r\n        promoCodeApplied: !!promoCodeId,\r\n        promoCode: appliedPromoCode\r\n      };\r\n\r\n      // Record promo code usage if payment was successful\r\n      if (result.success && userId && promoCodeId) {\r\n        await promoCodeService.recordPromoCodeUsage(\r\n          promoCodeId,\r\n          userId,\r\n          result.paymentId || ''\r\n        );\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      console.error('Payment processing error:', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown payment error'\r\n      };\r\n    }\r\n  }\r\n\r\n  // Verify payment status\r\n  async verifyPayment(paymentId: string): Promise<boolean> {\r\n    try {\r\n      // In a real implementation, this would make an API call to verify payment status\r\n      // For now, we'll simulate the API call with a promise\r\n\r\n      return await new Promise<boolean>((resolve) => {\r\n        // Simulate a longer verification process (3-5 seconds)\r\n        const verificationTime = 3000 + Math.random() * 2000;\r\n\r\n        setTimeout(() => {\r\n          // Simulate 80% success rate for payment verification\r\n          // This makes the payment process more realistic\r\n          const isVerified = Math.random() < 0.8;\r\n          resolve(isVerified);\r\n        }, verificationTime);\r\n      });\r\n    } catch (error) {\r\n      console.error('Payment verification error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Calculate price with promo code applied\r\n  async calculatePrice(plan: SubscriptionPlan, promoCode?: string, userId?: string): Promise<number> {\r\n    const originalPrice = this.prices[plan];\r\n\r\n    if (!promoCode || !userId) {\r\n      return originalPrice;\r\n    }\r\n\r\n    // Validate promo code\r\n    const validationResult = await promoCodeService.validatePromoCode(\r\n      promoCode,\r\n      plan === 'monthly' ? 'Monthly' : 'Annual',\r\n      userId\r\n    );\r\n\r\n    if (validationResult.isValid && validationResult.promoDetails) {\r\n      // Calculate discounted price\r\n      return this.calculateDiscountedPrice(originalPrice, validationResult.promoDetails);\r\n    }\r\n\r\n    return originalPrice;\r\n  }\r\n\r\n  // Calculate discounted price based on promo code\r\n  calculateDiscountedPrice(originalPrice: number, promoCode: PromoCode): number {\r\n    if (!promoCode) return originalPrice;\r\n\r\n    if (promoCode.discountType === 'free') return 0;\r\n\r\n    if (promoCode.discountType === 'percentage') {\r\n      const discountAmount = (originalPrice * promoCode.discountValue) / 100;\r\n      return Math.max(0, originalPrice - discountAmount);\r\n    }\r\n\r\n    if (promoCode.discountType === 'fixed') {\r\n      return Math.max(0, originalPrice - promoCode.discountValue);\r\n    }\r\n\r\n    return originalPrice;\r\n  }\r\n\r\n  // Save subscription to user profile\r\n  async saveSubscription(userId: string, subscriptionDetails: SubscriptionDetails): Promise<boolean> {\r\n    try {\r\n      // In a real implementation, this would save to a database\r\n      // For now, we'll use localStorage\r\n\r\n      // Get current user data\r\n      const userData = localStorage.getItem('user');\r\n      if (!userData) {\r\n        return false;\r\n      }\r\n\r\n      // Update user data with subscription details\r\n      const user = JSON.parse(userData);\r\n      user.subscription = subscriptionDetails;\r\n      user.isPremium = subscriptionDetails.status === 'active';\r\n\r\n      // Save updated user data\r\n      localStorage.setItem('user', JSON.stringify(user));\r\n\r\n      // In a real implementation, you would also save to Firestore\r\n      // const userRef = doc(db, 'users', userId);\r\n      // await updateDoc(userRef, {\r\n      //   subscription: subscriptionDetails,\r\n      //   isPremium: subscriptionDetails.status === 'active',\r\n      //   updatedAt: serverTimestamp()\r\n      // });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error saving subscription:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Cancel subscription\r\n  async cancelSubscription(userId: string): Promise<boolean> {\r\n    try {\r\n      // Get current user data\r\n      const userData = localStorage.getItem('user');\r\n      if (!userData) {\r\n        return false;\r\n      }\r\n\r\n      // Update user data with canceled subscription\r\n      const user = JSON.parse(userData);\r\n      if (user.subscription) {\r\n        // Store the original subscription details\r\n        const originalSubscription = { ...user.subscription };\r\n\r\n        // Update subscription status\r\n        user.subscription.status = 'canceled';\r\n        user.subscription.autoRenew = false;\r\n\r\n        // Save updated user data\r\n        localStorage.setItem('user', JSON.stringify(user));\r\n\r\n        // In a real implementation, you would also update Firestore\r\n        // const userRef = doc(db, 'users', userId);\r\n        // await updateDoc(userRef, {\r\n        //   'subscription.status': 'canceled',\r\n        //   'subscription.autoRenew': false,\r\n        //   updatedAt: serverTimestamp()\r\n        // });\r\n\r\n        // If there was a promo code, update its usage status\r\n        if (originalSubscription.promoCodeId) {\r\n          // In a real implementation, you would update the promo code usage\r\n          // const usageQuery = query(\r\n          //   collection(db, 'promoCodeUsages'),\r\n          //   where('promoCodeId', '==', originalSubscription.promoCodeId),\r\n          //   where('userId', '==', userId),\r\n          //   where('isActive', '==', true)\r\n          // );\r\n          //\r\n          // const usageSnapshot = await getDocs(usageQuery);\r\n          // if (!usageSnapshot.empty) {\r\n          //   const usageDoc = usageSnapshot.docs[0];\r\n          //   await updateDoc(doc(db, 'promoCodeUsages', usageDoc.id), {\r\n          //     isActive: false,\r\n          //     cancelledAt: serverTimestamp()\r\n          //   });\r\n          // }\r\n        }\r\n\r\n        // Offer a win-back promo code\r\n        this.offerWinbackPromoCode(userId);\r\n\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    } catch (error) {\r\n      console.error('Error canceling subscription:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Offer a win-back promo code after cancellation\r\n  private async offerWinbackPromoCode(userId: string): Promise<void> {\r\n    try {\r\n      // In a real implementation, you would check if the user is eligible for a win-back offer\r\n      // and add the 'cancellation' action to their profile\r\n\r\n      // const userRef = doc(db, 'users', userId);\r\n      // await updateDoc(userRef, {\r\n      //   actions: arrayUnion('cancellation'),\r\n      //   updatedAt: serverTimestamp()\r\n      // });\r\n\r\n      // For now, we'll just simulate this by showing a toast\r\n      toast({\r\n        title: \"Special Offer\",\r\n        description: \"Use code BREATHEAGAIN for 1 month free when you resubscribe!\"\r\n      });\r\n    } catch (error) {\r\n      console.error('Error offering win-back promo code:', error);\r\n    }\r\n  }\r\n\r\n  // Check if user has active subscription\r\n  hasActiveSubscription(userId: string): boolean {\r\n    try {\r\n      // Get current user data\r\n      const userData = localStorage.getItem('user');\r\n      if (!userData) {\r\n        return false;\r\n      }\r\n\r\n      // Check if user has active subscription\r\n      const user = JSON.parse(userData);\r\n      return user.isPremium === true &&\r\n             user.subscription?.status === 'active' &&\r\n             new Date(user.subscription.endDate) > new Date();\r\n    } catch (error) {\r\n      console.error('Error checking subscription:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Get subscription details\r\n  getSubscriptionDetails(userId: string): SubscriptionDetails | null {\r\n    try {\r\n      // Get current user data\r\n      const userData = localStorage.getItem('user');\r\n      if (!userData) {\r\n        return null;\r\n      }\r\n\r\n      // Get subscription details\r\n      const user = JSON.parse(userData);\r\n      return user.subscription || null;\r\n    } catch (error) {\r\n      console.error('Error getting subscription details:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Get consistent temporary user ID\r\n  private getTempUserId(): string {\r\n    // Check if we already have a temporary ID in localStorage\r\n    let tempId = localStorage.getItem('temp_user_id');\r\n\r\n    // If not, create a new one and store it\r\n    if (!tempId) {\r\n      tempId = `temp_user_${Date.now()}`;\r\n      localStorage.setItem('temp_user_id', tempId);\r\n    }\r\n\r\n    return tempId;\r\n  }\r\n\r\n  // Private helper methods\r\n  private validatePaymentDetails(details: PaymentDetails): boolean {\r\n    // In a real implementation, this would validate payment details\r\n    // For now, we'll just check if required fields are present based on payment method\r\n\r\n    if (details.method === 'credit_card') {\r\n      return !!(details.cardNumber && details.cardExpiry && details.cardCVC);\r\n    } else if (details.method === 'apple_pay' || details.method === 'google_pay' || details.method === 'balance') {\r\n      // For mobile payment methods and balance, we don't need additional validation\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const paymentService = new PaymentService();\r\n"],"names":["PaymentService","prices","monthly","annual","processPayment","plan","paymentDetails","promoCode","userId","originalPrice","finalPrice","appliedPromoCode","promoCodeId","validationResult","promoCodeService","validatePromoCode","isValid","promoDetails","calculateDiscountedPrice","id","validatePaymentDetails","success","error","paymentId","Math","random","toString","substring","now","Date","endDate","setMonth","getMonth","setFullYear","getFullYear","discountType","duration","durationValue","setDate","getDate","subscriptionDetails","startDate","autoRenew","status","priceInIDR","round","userIdToUse","getTempUserId","paymentDescription","deductResult","balanceService","deductBalance","method","result","promoCodeApplied","recordPromoCodeUsage","Error","message","verifyPayment","Promise","resolve","verificationTime","setTimeout","isVerified","calculatePrice","discountAmount","discountValue","max","saveSubscription","userData","localStorage","getItem","user","JSON","parse","subscription","isPremium","setItem","stringify","cancelSubscription","originalSubscription","offerWinbackPromoCode","toast","title","description","hasActiveSubscription","getSubscriptionDetails","tempId","details","cardNumber","cardExpiry","cardCVC","paymentService"],"mappings":"gTAwCA,MAAMA,CAAAA,CAAN,cAEUC,EAAAA,cAAS,CACfC,QAAS,KACTC,OAAQ,KAAA,GAIV,MAAMC,eACJC,EACAC,EACAC,EACAC,EACwB,CACpB,GAAA,CAEIC,MAAAA,EAAgB,KAAKR,OAAOI,CAAK,EACvC,IAAIK,EAAaD,EACbE,EACAC,EAGJ,GAAIL,GAAaC,EAAQ,CACjBK,MAAAA,EAAmB,MAAMC,EAAiBC,kBAC9CR,EACAF,IAAS,UAAY,UAAY,SACjCG,CAAAA,EAGEK,EAAiBG,SAAWH,EAAiBI,eAE/CP,EAAa,KAAKQ,yBAChBT,EACAI,EAAiBI,YAAY,EAG/BN,EAAmBE,EAAiBI,aACpCL,EAAcC,EAAiBI,aAAaE,GAEhD,CAGA,GAAI,CAAC,KAAKC,uBAAuBd,CAAiB,EACzC,MAAA,CACLe,QAAS,GACTC,MAAO,yBAAA,EAKLC,MAAAA,EAAY,OAAOC,KAAKC,OAASC,EAAAA,SAAS,EAAA,EAAIC,UAAU,EAAG,EAAK,CAAA,GAChEC,MAAUC,KAGVC,EAAU,IAAID,KAAKD,CAAAA,EACrBvB,IAAS,UACXyB,EAAQC,SAASD,EAAQE,SAAa,EAAA,CAAA,EAEtCF,EAAQG,YAAYH,EAAQI,YAAgB,EAAA,CAAA,EAI1CvB,GACAA,EAAiBwB,eAAiB,QAClCxB,EAAiByB,WAAa,QAC9BzB,EAAiB0B,eACnBP,EAAQQ,QAAQR,EAAQS,QAAO,EAAK5B,EAAiB0B,aAAa,EAIpE,MAAMG,EAA2C,CAC/CnC,KAAAA,EACAoC,UAAWb,EACXE,QAAAA,EACAY,UAAW,GACXC,OAAQ,UACRpB,UAAAA,EACAX,YAAAA,EACAH,cAAAA,EACAC,WAAAA,CAAAA,EAIIkC,EAAapB,KAAKqB,MAAMnC,EAAa,MAGrCoC,EAActC,GAAU,KAAKuC,cAAa,EAC1CC,EAAqB,mBAAmB3C,IAAS,UAAY,UAAY,QAAS,QAGlF4C,EAAe,MAAMC,EAAeC,cACxCL,EACAF,EACAI,EACA1C,EAAe8C,MAAM,EAGnB,GAAA,CAACH,EAAa5B,QACT,MAAA,CACLA,QAAS,GACTC,MAAO2B,EAAa3B,OAAS,gBAAA,EAKjCkB,EAAoBG,OAAS,SAG7B,MAAMU,EAAwB,CAC5BhC,QAAS,GACTE,UAAAA,EACAiB,oBAAAA,EACAc,iBAAkB,CAAC,CAAC1C,EACpBL,UAAWI,CAAAA,EAIT0C,OAAAA,EAAOhC,SAAWb,GAAUI,GAC9B,MAAME,EAAiByC,qBACrB3C,EACAJ,EACA6C,EAAO9B,WAAa,EAAA,EAIjB8B,QACA/B,EAAO,CACNA,eAAAA,MAAM,4BAA6BA,CAAAA,EACpC,CACLD,QAAS,GACTC,MAAOA,aAAiBkC,MAAQlC,EAAMmC,QAAU,uBAAA,CAEpD,CACF,CAGA,MAAMC,cAAcnC,EAAqC,CACnD,GAAA,CAIF,OAAO,MAAM,IAAIoC,QAAkBC,GAAAA,CAEjC,MAAMC,EAAmB,IAAOrC,KAAKC,OAAAA,EAAW,IAEhDqC,WAAW,IAAA,CAGHC,MAAAA,EAAavC,KAAKC,OAAAA,EAAW,GACnCmC,EAAQG,CAAAA,GACPF,CAAAA,CAAAA,CACL,QACOvC,EAAO,CACNA,eAAAA,MAAM,8BAA+BA,CAAAA,EACtC,EACT,CACF,CAGA,MAAM0C,eAAe3D,EAAwBE,EAAoBC,EAAkC,CAC3FC,MAAAA,EAAgB,KAAKR,OAAOI,CAAK,EAEnC,GAAA,CAACE,GAAa,CAACC,EACVC,OAAAA,EAIHI,MAAAA,EAAmB,MAAMC,EAAiBC,kBAC9CR,EACAF,IAAS,UAAY,UAAY,SACjCG,CAAAA,EAGEK,OAAAA,EAAiBG,SAAWH,EAAiBI,aAExC,KAAKC,yBAAyBT,EAAeI,EAAiBI,YAAY,EAG5ER,CACT,CAGAS,yBAAyBT,EAAuBF,EAA8B,CACxE,GAAA,CAACA,EAAkBE,OAAAA,EAEnBF,GAAAA,EAAU4B,eAAiB,OAAe,MAAA,GAE1C5B,GAAAA,EAAU4B,eAAiB,aAAc,CACrC8B,MAAAA,EAAkBxD,EAAgBF,EAAU2D,cAAiB,IACnE,OAAO1C,KAAK2C,IAAI,EAAG1D,EAAgBwD,CAAAA,CACrC,CAEI1D,OAAAA,EAAU4B,eAAiB,QACtBX,KAAK2C,IAAI,EAAG1D,EAAgBF,EAAU2D,aAAa,EAGrDzD,CACT,CAGA,MAAM2D,iBAAiB5D,EAAgBgC,EAA4D,CAC7F,GAAA,CAKI6B,MAAAA,EAAWC,aAAaC,QAAQ,MAAA,EACtC,GAAI,CAACF,EACI,MAAA,GAIHG,MAAAA,EAAOC,KAAKC,MAAML,CAAAA,EACxBG,OAAAA,EAAKG,aAAenC,EACfoC,EAAAA,UAAYpC,EAAoBG,SAAW,SAGhD2B,aAAaO,QAAQ,OAAQJ,KAAKK,UAAUN,CAAAA,CAAAA,EAUrC,SACAlD,EAAO,CACNA,eAAAA,MAAM,6BAA8BA,CAAAA,EACrC,EACT,CACF,CAGA,MAAMyD,mBAAmBvE,EAAkC,CACrD,GAAA,CAEI6D,MAAAA,EAAWC,aAAaC,QAAQ,MAAA,EACtC,GAAI,CAACF,EACI,MAAA,GAIHG,MAAAA,EAAOC,KAAKC,MAAML,CAAAA,EACxB,GAAIG,EAAKG,aAAc,CAErB,MAAMK,EAAuB,CAAE,GAAGR,EAAKG,YAAAA,EAGvCH,OAAAA,EAAKG,aAAahC,OAAS,WAC3B6B,EAAKG,aAAajC,UAAY,GAG9B4B,aAAaO,QAAQ,OAAQJ,KAAKK,UAAUN,CAAAA,CAAAA,EAWxCQ,EAAqBpE,YAoBzB,KAAKqE,sBAAsBzE,CAAAA,EAEpB,EACT,CAEO,MAAA,SACAc,EAAO,CACNA,eAAAA,MAAM,gCAAiCA,CAAAA,EACxC,EACT,CACF,CAGA,MAAc2D,sBAAsBzE,EAA+B,CAC7D,GAAA,CAWI0E,EAAA,CACJC,MAAO,gBACPC,YAAa,8DAAA,CACf,QACO9D,EAAO,CACNA,QAAAA,MAAM,sCAAuCA,CAAAA,CACvD,CACF,CAGA+D,sBAAsB7E,EAAyB,OACzC,GAAA,CAEI6D,MAAAA,EAAWC,aAAaC,QAAQ,MAAA,EACtC,GAAI,CAACF,EACI,MAAA,GAIHG,MAAAA,EAAOC,KAAKC,MAAML,CAAAA,EACxB,OAAOG,EAAKI,YAAc,MACnBJ,EAAAA,EAAKG,eAALH,YAAAA,EAAmB7B,UAAW,UAC9B,IAAId,KAAK2C,EAAKG,aAAa7C,OAAO,MAAQD,WAC1CP,EAAO,CACNA,eAAAA,MAAM,+BAAgCA,CAAAA,EACvC,EACT,CACF,CAGAgE,uBAAuB9E,EAA4C,CAC7D,GAAA,CAEI6D,MAAAA,EAAWC,aAAaC,QAAQ,MAAA,EACtC,OAAKF,GAKQI,KAAKC,MAAML,CAAAA,EACZM,cAAgB,WACrBrD,EAAO,CACNA,eAAAA,MAAM,sCAAuCA,CAAAA,EAC9C,IACT,CACF,CAGQyB,eAAwB,CAE1BwC,IAAAA,EAASjB,aAAaC,QAAQ,cAAA,EAGlC,OAAKgB,IACMA,EAAA,aAAa1D,KAAKD,IAAAA,CAAO,GACrBiD,aAAAA,QAAQ,eAAgBU,CAAAA,GAGhCA,CACT,CAGQnE,uBAAuBoE,EAAkC,CAI3DA,OAAAA,EAAQpC,SAAW,cACd,CAAC,EAAEoC,EAAQC,YAAcD,EAAQE,YAAcF,EAAQG,SACrDH,EAAQpC,SAAW,aAAeoC,EAAQpC,SAAW,cAAgBoC,EAAQpC,SAAW,SAMrG,CACF,CAGawC,MAAAA,EAAiB,IAAI5F"}